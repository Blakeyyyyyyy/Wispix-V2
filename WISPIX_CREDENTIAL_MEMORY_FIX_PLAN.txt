# COMPREHENSIVE FIX FOR WISPIX AGENT SYSTEM

## ðŸ”´ CRITICAL ISSUES IDENTIFIED

### Issue 1: **Schema Mismatch in Credential Storage**
The system stores credentials in TWO DIFFERENT FORMATS:

**Format A** (from CredentialForm â†’ encrypt-credentials API):
```json
{
  "service_name": "airtable_credentials",
  "platform": "airtable",
  "credentials": {"encrypted": "..."}
}
```

**Format B** (actual stored data):
```json
{
  "service_name": "airtable_personal_access_token",
  "platform": null,
  "credentials": {
    "user_id": "...",
    "platform": "Airtable",
    "credential_name": "Personal Access Token",
    "credential_value": "pat5n3snH265TNN05..."
  }
}
```

**Agent 1's checkCredentials tool queries:**
```javascript
filters: {
  conditions: [
    { keyName: "user_id", condition: "eq", keyValue: user_id }
  ]
}
```

This returns ALL credentials but Agent 1 doesn't know how to parse the nested structure.

### Issue 2: **Message Format Mismatch**
Agent 1 returns:
```json
{
  "type": "credential_request",
  "platform": "airtable"
}
```

Frontend expects:
```json
{
  "action": "CREDENTIAL_REQUEST",
  "platform": "airtable"
}
```

### Issue 3: **Missing Post-Credential Logic**
Agent 1's prompt says "create execution plan when you have everything" but doesn't specify:
- How to detect "Credentials have been updated successfully" as a continuation signal
- That it should immediately verify credentials and proceed

### Issue 4: **Memory Session Key is Correct BUT...**
```javascript
sessionKey: "={{ $json.body.thread_id }}"
```
This is correct, but the issue is the **payload structure** sent to N8N may not include `thread_id` consistently.

---

## ðŸŽ¯ COMPREHENSIVE FIX PLAN

### **PHASE 1: Fix Credential Storage (IMMEDIATE)**

#### Step 1A: Standardize Database Schema
```sql
-- Fix existing credentials to have platform column
UPDATE user_credentials 
SET platform = CASE 
  WHEN service_name LIKE '%airtable%' THEN 'airtable'
  WHEN service_name LIKE '%slack%' THEN 'slack'
  WHEN service_name LIKE '%gmail%' THEN 'gmail'
  WHEN service_name LIKE '%stripe%' THEN 'stripe'
  ELSE LOWER(SPLIT_PART(service_name, '_', 1))
END
WHERE platform IS NULL;

-- Add constraint to prevent future null platforms
ALTER TABLE user_credentials 
ALTER COLUMN platform SET NOT NULL;

-- Create compound index for fast lookups
CREATE INDEX IF NOT EXISTS idx_user_creds_platform 
ON user_credentials(user_id, platform);
```

#### Step 1B: Fix encrypt-credentials API
```javascript
// api/encrypt-credentials.js
const credentialData = {
  user_id: userId,
  platform: platform.toLowerCase(), // Ensure lowercase "airtable"
  service_name: `${platform.toLowerCase()}_credentials`, // "airtable_credentials"
  credentials: {
    [credentialName]: credentialValue // Direct key-value, no nesting
  },
  encrypted: false, // Start unencrypted for debugging
  created_at: new Date().toISOString()
};

// Upsert with proper conflict handling
const { data, error } = await supabase
  .from('user_credentials')
  .upsert(credentialData, {
    onConflict: 'user_id,platform', // Match on user+platform, not service_name
    ignoreDuplicates: false
  })
  .select()
  .single();
```

#### Step 1C: Update CredentialForm to Store Simple Format
```typescript
// src/components/CredentialForm.tsx
const handleSubmit = async (e) => {
  e.preventDefault();
  
  const response = await fetch('/api/encrypt-credentials', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      userId: userId,
      platform: selectedPlatform.toLowerCase(), // "airtable"
      credentialName: credentialInputs[0].name, // "personal_access_token"
      credentialValue: credentialInputs[0].value, // "pat5n3s..."
    })
  });
  
  if (response.ok) {
    onCredentialSubmitted('Credentials have been updated successfully');
    onClose();
  }
};
```

---

### **PHASE 2: Fix Agent 1 Credential Detection**

#### Step 2A: Enhanced N8N System Prompt
Add this section BEFORE the existing prompt:

```
=== CREDENTIAL CHECKING PROTOCOL ===

STEP 1 - Check Existing Credentials:
When user requests an automation involving a platform (Airtable, Slack, Gmail, etc.):
1. IMMEDIATELY call Get_Credentials_Supabase tool
2. The tool returns ALL user credentials as an array
3. Parse the response to find if the needed platform exists:
   - Look for credentials where credentials object has the needed key
   - For Airtable: check if any credential has "personal_access_token" or "credential_value"
   - For Slack: check for "bot_token" or "access_token"
   - For Gmail: check for "refresh_token"

STEP 2 - If Credentials Missing:
Return EXACTLY this format:
{
  "action": "CREDENTIAL_REQUEST",
  "platform": "airtable",
  "fields": ["personal_access_token"],
  "message": "I need your Airtable Personal Access Token to proceed."
}

STEP 3 - If Credentials Exist:
Proceed immediately to collect other parameters (baseId, tableId, etc.)

STEP 4 - After User Says "Credentials have been updated successfully":
1. Call Get_Credentials_Supabase again to verify
2. If found, respond: "Perfect! Now I need a few details..."
3. Collect remaining parameters (baseId, tableId, etc.)
4. Once you have ALL information, return FLOW_CHANGE format

CRITICAL: Do NOT ask for credentials twice. Check first, request only if missing.
```

#### Step 2B: Add Credential Parsing Logic to Agent 1
In the N8N workflow, add a **Code node** after Get_Credentials_Supabase that processes the response:

```javascript
// Code Node: Parse Credentials
const allCredentials = $input.all();
const platform = $json.body.platform; // e.g., "airtable"

// Find credential for this platform
const platformCred = allCredentials.find(cred => 
  cred.json.platform === platform || 
  cred.json.service_name?.includes(platform)
);

if (!platformCred) {
  return [{
    json: {
      has_credentials: false,
      platform: platform,
      message: `No ${platform} credentials found`
    }
  }];
}

// Extract actual credential value from nested structure
const credData = platformCred.json.credentials;
const credValue = credData.credential_value || 
                  credData.personal_access_token || 
                  credData.access_token ||
                  credData.api_key;

return [{
  json: {
    has_credentials: !!credValue,
    platform: platform,
    credential_value: credValue,
    message: `Found ${platform} credentials`
  }
}];
```

---

### **PHASE 3: Fix Message Format Consistency**

#### Step 3A: Update Agent 1 Output Parser
In your N8N Agent 1 workflow, add a **Code node** BEFORE responding to format the output:

```javascript
// Code Node: Format Response
const agentOutput = $input.first().json;

// Detect if this is a credential request
if (agentOutput.includes('need') && agentOutput.includes('credentials')) {
  return [{
    json: {
      action: "CREDENTIAL_REQUEST", // Changed from "type"
      platform: extractPlatform(agentOutput), // Extract from message
      fields: ["personal_access_token"],
      message: agentOutput
    }
  }];
}

// Detect if this is a flow change
if (agentOutput.includes('FlowChange: true')) {
  // Parse steps and return proper format
  return [{
    json: {
      FlowChange: true,
      steps: parseSteps(agentOutput),
      ProjectContext: extractContext(agentOutput)
    }
  }];
}

// Regular message
return [{
  json: {
    message: agentOutput,
    action: "MESSAGE"
  }
}];

function extractPlatform(text) {
  if (text.toLowerCase().includes('airtable')) return 'airtable';
  if (text.toLowerCase().includes('slack')) return 'slack';
  if (text.toLowerCase().includes('gmail')) return 'gmail';
  return 'unknown';
}
```

---

### **PHASE 4: Fix Post-Credential Flow**

#### Step 4A: Update ChatInterface Message Handler
```typescript
// src/components/ChatInterface.tsx
const handleCredentialSubmit = async (credentials) => {
  // Save credentials
  await saveCredentials(credentials);
  
  // Send EXPLICIT continuation message to Agent 1
  await sendMessage({
    content: "Credentials have been updated successfully. Continue creating the automation.",
    metadata: {
      type: 'CREDENTIAL_CONFIRMATION',
      platform: credentialPopup.platform,
      timestamp: Date.now()
    }
  });
  
  setCredentialPopup(null);
};
```

#### Step 4B: Enhance Agent 1 to Detect Continuation
Add to Agent 1 system prompt:

```
=== CONTINUATION DETECTION ===

When you see the message: "Credentials have been updated successfully"
This means:
1. User has just submitted credentials
2. You should verify credentials were saved (call Get_Credentials_Supabase)
3. If verified, IMMEDIATELY ask for remaining parameters (baseId, tableId, etc.)
4. Do NOT ask for credentials again

Example response:
"Great! Your Airtable credentials are saved. Now I need:
1. Your Airtable Base ID (starts with 'app')
2. Your Table ID or name
What are these values?"
```

---

### **PHASE 5: Fix Thread Memory Payload**

#### Step 5A: Ensure Consistent thread_id in N8N Payloads
In `api/send-message-agent1.js`:

```javascript
const payload = {
  body: {
    thread_id: threadId, // Must match N8N sessionKey
    automation_id: automationId,
    user_id: userId,
    message: content,
    timestamp: Date.now()
  }
};

const response = await fetch(AGENT1_WEBHOOK_URL, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(payload)
});
```

---

## ðŸ§ª TESTING PROTOCOL

### Test 1: Credential Detection
```
User: "Create an automation to delete a record from my Airtable"
Expected: Agent 1 calls Get_Credentials_Supabase
Expected: If credentials exist, Agent 1 asks for baseId/tableId WITHOUT requesting credentials
Expected: If credentials missing, Agent 1 returns {action: "CREDENTIAL_REQUEST"}
```

### Test 2: Credential Request Flow
```
User: "Create automation..." (no credentials)
Expected: Credential popup appears
User: Submits PAT
Expected: Message "Credentials have been updated successfully. Continue..."
Expected: Agent 1 responds "Great! Now I need baseId and tableId"
Expected: NO second credential request
```

### Test 3: Memory Persistence
```
User: "Create automation..."
Agent: "What's your baseId?"
User: "appXYZ123"
Agent: "What's your tableId?"
User: "tblABC456"
Expected: Agent remembers appXYZ123 when creating execution plan
```

---

## ðŸ“‹ IMPLEMENTATION PRIORITY

### Priority 1: Fix Credential Storage Schema
1. Run the SQL migration in PHASE 1 Step 1A to standardize platform column
2. Update api/encrypt-credentials.js per PHASE 1 Step 1B
3. Update src/components/CredentialForm.tsx per PHASE 1 Step 1C

### Priority 2: Fix Agent 1 Credential Detection
1. Add the enhanced system prompt from PHASE 2 Step 2A to your N8N Agent 1
2. Add the Code node from PHASE 2 Step 2B after Get_Credentials_Supabase tool

### Priority 3: Fix Message Format
1. Add the Code node from PHASE 3 Step 3A to format Agent 1 responses
2. Ensure all responses use "action" field instead of "type"

### Priority 4: Fix Post-Credential Flow
1. Update ChatInterface.tsx per PHASE 4 Step 4A
2. Add continuation detection to Agent 1 prompt per PHASE 4 Step 4B

### Priority 5: Verify Thread Memory
1. Ensure api/send-message-agent1.js includes thread_id in payload per PHASE 5 Step 5A

## Testing
After each phase, run the tests from the TESTING PROTOCOL section.

---

## CURRENT SYSTEM ANALYSIS

### What's Working:
- Credential form submission
- Encryption API endpoint
- Agent 1 conversation flow
- Tool definitions in database

### What's Broken:
- Credential detection (schema mismatch)
- Message format consistency
- Post-credential continuation
- Context memory persistence

### Root Causes:
1. Database schema inconsistency between old and new credential formats
2. Message format mismatch between Agent 1 output and frontend expectations
3. Missing continuation logic after credential submission
4. Context storage not properly implemented in database

This comprehensive fix addresses all identified issues while maintaining the tool-based architecture.
